import math
from machine import Pin, SPI
import time

WIDTH = 128
HEIGHT = 64
PAGES = HEIGHT // 8

# Simple 8x16 Font (ASCII 32 to 127), as an example
# FONT_8x16 = {
#     'A': [0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00, 0x00, 0x00],  # Example: 'A'
#     'B': [0xFF, 0x91, 0x91, 0x91, 0x6E, 0x00, 0x00, 0x00],  # Example: 'B'
#     ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],  # Space
#     # Add more characters as needed
# }

FONT_8x16 = {
    ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],  # Space
    '!': [0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00],  # !
    '"': [0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00],  # "
    '#': [0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00, 0x00],  # #
    '$': [0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00, 0x00],  # $
    '%': [0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00, 0x00],  # %
    '&': [0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00, 0x00],  # &
    "'": [0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00],  # '
    '(': [0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00],  # (
    ')': [0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00],  # )
    '*': [0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00, 0x00],  # *
    '+': [0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00],  # +
    ',': [0x00, 0x50, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],  # ,
    '-': [0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00],  # -
    '.': [0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00],  # .
    '/': [0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00],  # /
    '0': [0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00, 0x00],  # 0
    '1': [0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00],  # 1
    '2': [0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00, 0x00],  # 2
    '3': [0x21, 0x41, 0x45, 0x4B, 0x31, 0x00, 0x00, 0x00],  # 3
    '4': [0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00, 0x00],  # 4
    '5': [0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00, 0x00],  # 5
    '6': [0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00, 0x00],  # 6
    '7': [0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00, 0x00],  # 7
    '8': [0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00],  # 8
    '9': [0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00, 0x00],  # 9
    ':': [0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00],  # :
    ';': [0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00],  # ;
    '<': [0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00],  # <
    '=': [0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00],  # =
    '>': [0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00, 0x00],  # >
    '?': [0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00, 0x00],  # ?
    '@': [0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00, 0x00],  # @
    'A': [0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00, 0x00, 0x00],  # A
    'B': [0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00],  # B
    'C': [0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00, 0x00],  # C
    'D': [0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00],  # D
    'E': [0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, 0x00],  # E
    'F': [0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, 0x00],  # F
    'G': [0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, 0x00, 0x00],  # G
    'H': [0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00, 0x00],  # H
    'I': [0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00],  # I
    'J': [0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00, 0x00],  # J
    'K': [0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00],  # K
    'L': [0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00],  # L
    'M': [0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00, 0x00],  # M
    'N': [0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00, 0x00],  # N
    'O': [0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00, 0x00],  # O
    'P': [0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00],  # P
    'Q': [0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00, 0x00],  # Q
    'R': [0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00, 0x00],  # R
    'S': [0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00, 0x00],  # S
    'T': [0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00, 0x00],  # T
    'U': [0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00],  # U
    'V': [0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00, 0x00],  # V
    'W': [0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00, 0x00],  # W
    'X': [0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00, 0x00],  # X
    'Y': [0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00, 0x00],  # Y
    'Z': [0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00],  # Z
    '[': [0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00],  # [
    '\\': [0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00], # \
    ']': [0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00, 0x00],  # ]
    '^': [0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00],  # ^
    '_': [0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00],  # _
    '`': [0x00, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00],  # `
    'a': [0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00, 0x00],  # a
    'b': [0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00],  # b
    'c': [0x38, 0x44, 0x44, 0x44, 0x20, 0x00, 0x00, 0x00],  # c
    'd': [0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00, 0x00],  # d
    'e': [0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00, 0x00],  # e
    'f': [0x08, 0x7E, 0x09, 0x01, 0x02, 0x00, 0x00, 0x00],  # f
    'g': [0x08, 0x14, 0x54, 0x54, 0x3C, 0x00, 0x00, 0x00],  # g
    'h': [0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00],  # h
    'i': [0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, 0x00, 0x00],  # i
    'j': [0x20, 0x40, 0x44, 0x3D, 0x00, 0x00, 0x00, 0x00],  # j
    'k': [0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00],  # k
    'l': [0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00],  # l
    'm': [0x7C, 0x04, 0x78, 0x04, 0x78, 0x00, 0x00, 0x00],  # m
    'n': [0x7C, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00],  # n
    'o': [0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00],  # o
    'p': [0x7C, 0x14, 0x14, 0x14, 0x08, 0x00, 0x00, 0x00],  # p
    'q': [0x08, 0x14, 0x14, 0x18, 0x7C, 0x00, 0x00, 0x00],  # q
    'r': [0x7C, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00],  # r
    's': [0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00, 0x00],  # s
    't': [0x04, 0x3F, 0x44, 0x40, 0x20, 0x00, 0x00, 0x00],  # t
    'u': [0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00, 0x00, 0x00],  # u
    'v': [0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00, 0x00],  # v
    'w': [0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00, 0x00],  # w
    'x': [0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00],  # x
    'y': [0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00, 0x00, 0x00],  # y
    'z': [0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00, 0x00],  # z
    '{': [0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00],  # {
    '|': [0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00],  # |
    '}': [0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00],  # }
    '~': [0x08, 0x08, 0x2A, 0x1C, 0x08, 0x00, 0x00, 0x00],  # ~
}


class ST7565:
    def __init__(self, spi, cs_pin, a0_pin, reset_pin):
        self.spi = spi
        self.cs = Pin(cs_pin, Pin.OUT)
        self.a0 = Pin(a0_pin, Pin.OUT)
        self.reset = Pin(reset_pin, Pin.OUT)
        
        self.buffer = bytearray(WIDTH * PAGES)
        self.back_buffer = bytearray(WIDTH * PAGES)
        self.dirty_pages = [False] * PAGES  # Track dirty pages for partial updates
        
        self.reset_display()
        self.initialize_display()
    
    def reset_display(self):
        self.reset.value(0)
        time.sleep(0.05)
        self.reset.value(1)
    
    def send_command(self, cmd):
        self.a0.value(0)  # Command mode
        self.cs.value(0)
        self.spi.write(bytearray([cmd]))
        self.cs.value(1)
        
    def send_data(self, data):
        self.a0.value(1)  # Data mode
        self.cs.value(0)
        self.spi.write(data)
        self.cs.value(1)
    
    def initialize_display(self):
        self.send_command(0xE2)  # System reset
        time.sleep(0.05)
        self.send_command(0xAE)  # Display off
        self.send_command(0xA2)  # Bias 1/9
        self.send_command(0xA0)  # ADC select, normal
        self.send_command(0xC8)  # COM output, reversed
        self.send_command(0x2F)  # Power control, operating mode
        self.send_command(0x40)  # Start line = 0
        self.send_command(0xAF)  # Display on
    
    def update(self):
        for page in range(PAGES):
            if self.dirty_pages[page]:
                self.send_command(0xB0 | page)  # Set page address
                self.send_command(0x10)         # Set column upper address
                self.send_command(0x00)         # Set column lower address
                self.send_data(self.back_buffer[page * WIDTH: (page + 1) * WIDTH])
                self.dirty_pages[page] = False  # Reset the dirty flag after updating
    
    def swap_buffers(self):
        self.buffer, self.back_buffer = self.back_buffer, self.buffer
    
    def set_pixel(self, x, y, color):
        if x < 0 or x >= WIDTH or y < 0 or y >= HEIGHT:
            return
        
        page = y // 8
        bit_mask = 1 << (y % 8)
        
        if color:
            self.back_buffer[page * WIDTH + x] |= bit_mask
        else:
            self.back_buffer[page * WIDTH + x] &= ~bit_mask
        
        self.dirty_pages[page] = True  # Mark this page as dirty
    
    def clear(self):
        for i in range(len(self.back_buffer)):
            self.back_buffer[i] = 0
        self.dirty_pages = [True] * PAGES  # Mark all pages as dirty

    def draw_line(self, x0, y0, x1, y1, color, anti_alias=False):
        """Draws a line using Bresenham's algorithm, with optional anti-aliasing"""
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        sx = 1 if x0 < x1 else -1
        sy = 1 if y0 < y1 else -1
        err = dx - dy
        
        while True:
            self.set_pixel(x0, y0, color)
            if anti_alias:  # Anti-aliased version: activate adjacent pixels
                if x0 + 1 < WIDTH:
                    self.set_pixel(x0 + 1, y0, color // 2)
                if y0 + 1 < HEIGHT:
                    self.set_pixel(x0, y0 + 1, color // 2)
            
            if x0 == x1 and y0 == y1:
                break
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x0 += sx
            if e2 < dx:
                err += dx
                y0 += sy

    ### Part 1: Vertical Scrolling ###
    def scroll_vertical(self, direction, speed=1, text=None, image=None, shape=None):
        """Scroll text, image, or shapes vertically on the display."""
        for offset in range(0, HEIGHT, speed):
            self.clear()
            if direction == "up":
                scroll_offset = HEIGHT - offset
            else:  # direction == "down"
                scroll_offset = offset
            
            if text:
                self.draw_text_8x16(0, scroll_offset, text, 1)
            if image:
                self.draw_bitmap(0, scroll_offset, image, WIDTH, HEIGHT)
            if shape:
                self.draw_shape(scroll_offset)
            
            self.draw()
            time.sleep(0.05)

    ### Part 2: Bitmap Rendering with Dithering ###
    def draw_bitmap(self, x, y, bitmap, width, height):
        """Draw a monochrome bitmap at position (x, y)."""
        for j in range(height):
            for i in range(width):
                if (i + x < WIDTH) and (j + y < HEIGHT):
                    pixel = (bitmap[j * width + i] > 127)  # Assume bitmap values 0-255, threshold at 128
                    self.set_pixel(i + x, j + y, pixel)
    
    def draw_shape(self, y_offset):
        """Draw a simple shape for scrolling demonstration."""
        self.draw_rect(10, y_offset + 10, 50, 20, 1)
        self.draw_circle(70, y_offset + 20, 10, 1, filled=True)
    
    ### Text and Shape Drawing (already available from previous code) ###
    def draw_text_8x16(self, x, y, text, color):
        """Draws text using the 8x16 font"""
        for char in text:
            char_data = FONT_8x16.get(char, FONT_8x16[' '])
            for i in range(8):
                col = char_data[i]
                for j in range(8):
                    self.set_pixel(x + i, y + j, (col >> j) & 1 if color else 0)
            x += 8  # Move the cursor for the next character
    
    def draw_rect(self, x, y, w, h, color, filled=False):
        """Draws a rectangle, optionally filled"""
        if filled:
            for i in range(y, y + h):
                self.draw_line(x, i, x + w - 1, i, color)
        else:
            self.draw_line(x, y, x + w - 1, y, color)
            self.draw_line(x, y + h - 1, x + w - 1, y + h - 1, color)
            self.draw_line(x, y, x, y + h - 1, color)
            self.draw_line(x + w - 1, y, x + w - 1, y + h - 1, color)
    
    def draw_circle(self, x0, y0, r, color, filled=False):
        """Draws a circle, optionally filled"""
        f = 1 - r
        ddF_x = 1
        ddF_y = -2 * r
        x = 0
        y = r
        
        self.set_pixel(x0, y0 + r, color)
        self.set_pixel(x0, y0 - r, color)
        self.set_pixel(x0 + r, y0, color)
        self.set_pixel(x0 - r, y0, color)
        
        while x < y:
            if f >= 0:
                y -= 1
                ddF_y += 2
                f += ddF_y
            x += 1
            ddF_x += 2
            f += ddF_x
            
            self.set_pixel(x0 + x, y0 + y, color)
            self.set_pixel(x0 - x, y0 + y, color)
            self.set_pixel(x0 + x, y0 - y, color)
            self.set_pixel(x0 - x, y0 - y, color)
            self.set_pixel(x0 + y, y0 + x, color)
            self.set_pixel(x0 - y, y0 + x, color)
            self.set_pixel(x0 + y, y0 - x, color)
            self.set_pixel(x0 - y, y0 - x, color)
            
            if filled:
                self.draw_line(x0 - x, y0 + y, x0 + x, y0 + y, color)
                self.draw_line(x0 - x, y0 - y, x0 + x, y0 - y, color)
                self.draw_line(x0 - y, y0 + x, x0 + y, y0 + x, color)
                self.draw_line(x0 - y, y0 - x, x0 + y, y0 - x, color)
    
    ### The draw() function ###
    def draw(self):
        self.update()  # Update only the dirty pages
        self.swap_buffers()  # Swap buffers for double buffering

# from machine import SPI

# CS1 = Pin(5, Pin.OUT)  # Chip Select
# RS = Pin(19, Pin.OUT)  # Register Select (A0 on ST7565R)
# RST = Pin(17, Pin.OUT) # Reset


# SDA = Pin(23, Pin.OUT) # MOSI (Data)
# SCK = Pin(18, Pin.OUT) # SCLK (Clock)

SDA = Pin(27, Pin.OUT) # MOSI (Data)
SCK = Pin(26, Pin.OUT) # SCLK (Clock)

# SPI Configuration for the display (SPI communication)
spi = SPI(1, baudrate=1000000, polarity=0, phase=0, sck=SCK, mosi=SDA)

# Initialize SPI bus and display
# spi = SPI(1, baudrate=1000000, polarity=0, phase=0)
# display = ST7565(spi, cs_pin=5, a0_pin=19, reset_pin=17)

display = ST7565(spi, cs_pin=2, a0_pin=32, reset_pin=33)

# Example of vertical scrolling with text
# display.scroll_vertical("up", speed=1, text="HELLO")

# # Example of vertical scrolling with a shape
# display.scroll_vertical("down", speed=1, shape=True)

# Example of drawing a bitmap
# bitmap = [0xFF if (i % 2 == 0) else 0x00 for i in range(128 * 64)]  # Simple checkerboard
# display.draw_bitmap(0, 0, bitmap, 128, 64)

# Update the display
while True:
    display.clear()
    display.scroll_vertical("up", speed=1, text="HELLO")
    display.scroll_vertical("down", speed=1, shape=True)
    display.draw()
